import{e as M,g as z,r as $,a as j,b as F,c as Y,d as H,f as G,h as J,i as K,j as N,k as B,l as I,m as X,n as Q}from"./@floating-ui.utils-Bh-IyuRp.js";function _(i,s,m){let{reference:n,floating:r}=i;const e=Y(s),l=H(s),o=I(l),g=j(s),x=e==="y",d=n.x+n.width/2-r.width/2,c=n.y+n.height/2-r.height/2,f=n[o]/2-r[o]/2;let t;switch(g){case"top":t={x:d,y:n.y-r.height};break;case"bottom":t={x:d,y:n.y+n.height};break;case"right":t={x:n.x+n.width,y:c};break;case"left":t={x:n.x-r.width,y:c};break;default:t={x:n.x,y:n.y}}switch(F(s)){case"start":t[l]-=f*(m&&x?-1:1);break;case"end":t[l]+=f*(m&&x?-1:1);break}return t}const tt=async(i,s,m)=>{const{placement:n="bottom",strategy:r="absolute",middleware:e=[],platform:l}=m,o=e.filter(Boolean),g=await(l.isRTL==null?void 0:l.isRTL(s));let x=await l.getElementRects({reference:i,floating:s,strategy:r}),{x:d,y:c}=_(x,n,g),f=n,t={},a=0;for(let w=0;w<o.length;w++){const{name:u,fn:p}=o[w],{x:h,y,data:P,reset:v}=await p({x:d,y:c,initialPlacement:n,placement:f,strategy:r,middlewareData:t,rects:x,platform:l,elements:{reference:i,floating:s}});d=h??d,c=y??c,t={...t,[u]:{...t[u],...P}},v&&a<=50&&(a++,typeof v=="object"&&(v.placement&&(f=v.placement),v.rects&&(x=v.rects===!0?await l.getElementRects({reference:i,floating:s,strategy:r}):v.rects),{x:d,y:c}=_(x,f,g)),w=-1)}return{x:d,y:c,placement:f,strategy:r,middlewareData:t}};async function W(i,s){var m;s===void 0&&(s={});const{x:n,y:r,platform:e,rects:l,elements:o,strategy:g}=i,{boundary:x="clippingAncestors",rootBoundary:d="viewport",elementContext:c="floating",altBoundary:f=!1,padding:t=0}=M(s,i),a=z(t),u=o[f?c==="floating"?"reference":"floating":c],p=$(await e.getClippingRect({element:(m=await(e.isElement==null?void 0:e.isElement(u)))==null||m?u:u.contextElement||await(e.getDocumentElement==null?void 0:e.getDocumentElement(o.floating)),boundary:x,rootBoundary:d,strategy:g})),h=c==="floating"?{...l.floating,x:n,y:r}:l.reference,y=await(e.getOffsetParent==null?void 0:e.getOffsetParent(o.floating)),P=await(e.isElement==null?void 0:e.isElement(y))?await(e.getScale==null?void 0:e.getScale(y))||{x:1,y:1}:{x:1,y:1},v=$(e.convertOffsetParentRelativeRectToViewportRelativeRect?await e.convertOffsetParentRelativeRectToViewportRelativeRect({elements:o,rect:h,offsetParent:y,strategy:g}):h);return{top:(p.top-v.top+a.top)/P.y,bottom:(v.bottom-p.bottom+a.bottom)/P.y,left:(p.left-v.left+a.left)/P.x,right:(v.right-p.right+a.right)/P.x}}const et=i=>({name:"arrow",options:i,async fn(s){const{x:m,y:n,placement:r,rects:e,platform:l,elements:o,middlewareData:g}=s,{element:x,padding:d=0}=M(i,s)||{};if(x==null)return{};const c=z(d),f={x:m,y:n},t=H(r),a=I(t),w=await l.getDimensions(x),u=t==="y",p=u?"top":"left",h=u?"bottom":"right",y=u?"clientHeight":"clientWidth",P=e.reference[a]+e.reference[t]-f[t]-e.floating[a],v=f[t]-e.reference[t],D=await(l.getOffsetParent==null?void 0:l.getOffsetParent(x));let O=D?D[y]:0;(!O||!await(l.isElement==null?void 0:l.isElement(D)))&&(O=o.floating[y]||e.floating[a]);const E=P/2-v/2,S=O/2-w[a]/2-1,T=X(c[p],S),L=X(c[h],S),b=T,V=O-w[a]-L,A=O/2-w[a]/2+E,R=B(b,A,V),k=!g.arrow&&F(r)!=null&&A!==R&&e.reference[a]/2-(A<b?T:L)-w[a]/2<0,C=k?A<b?A-b:A-V:0;return{[t]:f[t]+C,data:{[t]:R,centerOffset:A-R-C,...k&&{alignmentOffset:C}},reset:k}}}),nt=function(i){return i===void 0&&(i={}),{name:"flip",options:i,async fn(s){var m,n;const{placement:r,middlewareData:e,rects:l,initialPlacement:o,platform:g,elements:x}=s,{mainAxis:d=!0,crossAxis:c=!0,fallbackPlacements:f,fallbackStrategy:t="bestFit",fallbackAxisSideDirection:a="none",flipAlignment:w=!0,...u}=M(i,s);if((m=e.arrow)!=null&&m.alignmentOffset)return{};const p=j(r),h=j(o)===o,y=await(g.isRTL==null?void 0:g.isRTL(x.floating)),P=f||(h||!w?[G(o)]:J(o));!f&&a!=="none"&&P.push(...K(o,w,a,y));const v=[o,...P],D=await W(s,u),O=[];let E=((n=e.flip)==null?void 0:n.overflows)||[];if(d&&O.push(D[p]),c){const b=N(r,l,y);O.push(D[b[0]],D[b[1]])}if(E=[...E,{placement:r,overflows:O}],!O.every(b=>b<=0)){var S,T;const b=(((S=e.flip)==null?void 0:S.index)||0)+1,V=v[b];if(V)return{data:{index:b,overflows:E},reset:{placement:V}};let A=(T=E.filter(R=>R.overflows[0]<=0).sort((R,k)=>R.overflows[1]-k.overflows[1])[0])==null?void 0:T.placement;if(!A)switch(t){case"bestFit":{var L;const R=(L=E.map(k=>[k.placement,k.overflows.filter(C=>C>0).reduce((C,q)=>C+q,0)]).sort((k,C)=>k[1]-C[1])[0])==null?void 0:L[0];R&&(A=R);break}case"initialPlacement":A=o;break}if(r!==A)return{reset:{placement:A}}}return{}}}};async function U(i,s){const{placement:m,platform:n,elements:r}=i,e=await(n.isRTL==null?void 0:n.isRTL(r.floating)),l=j(m),o=F(m),g=Y(m)==="y",x=["left","top"].includes(l)?-1:1,d=e&&g?-1:1,c=M(s,i);let{mainAxis:f,crossAxis:t,alignmentAxis:a}=typeof c=="number"?{mainAxis:c,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...c};return o&&typeof a=="number"&&(t=o==="end"?a*-1:a),g?{x:t*d,y:f*x}:{x:f*x,y:t*d}}const st=function(i){return i===void 0&&(i=0),{name:"offset",options:i,async fn(s){var m,n;const{x:r,y:e,placement:l,middlewareData:o}=s,g=await U(s,i);return l===((m=o.offset)==null?void 0:m.placement)&&(n=o.arrow)!=null&&n.alignmentOffset?{}:{x:r+g.x,y:e+g.y,data:{...g,placement:l}}}}},it=function(i){return i===void 0&&(i={}),{name:"shift",options:i,async fn(s){const{x:m,y:n,placement:r}=s,{mainAxis:e=!0,crossAxis:l=!1,limiter:o={fn:u=>{let{x:p,y:h}=u;return{x:p,y:h}}},...g}=M(i,s),x={x:m,y:n},d=await W(s,g),c=Y(j(r)),f=Q(c);let t=x[f],a=x[c];if(e){const u=f==="y"?"top":"left",p=f==="y"?"bottom":"right",h=t+d[u],y=t-d[p];t=B(h,t,y)}if(l){const u=c==="y"?"top":"left",p=c==="y"?"bottom":"right",h=a+d[u],y=a-d[p];a=B(h,a,y)}const w=o.fn({...s,[f]:t,[c]:a});return{...w,data:{x:w.x-m,y:w.y-n}}}}};export{et as a,tt as c,W as d,nt as f,st as o,it as s};
